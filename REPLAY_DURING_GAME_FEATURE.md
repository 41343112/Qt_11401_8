# 遊戲進行中的回放功能

## 概述

此更新實現了在遊戲進行中查看回放的功能。之前，回放功能僅在遊戲結束後可用。現在玩家可以在遊戲進行中雙擊棋譜列表中的任何步驟來查看該步驟的棋盤狀態，並使用導航按鈕瀏覽整個對局。

## 問題描述

**原始問題**：固定回放的按鍵 遊戲中也可以看回放

之前的實現在 `qt_chess.cpp` 第 175 行有一個檢查：
```cpp
if (!m_gameStarted) {  // 只有在遊戲結束後才允許回放
```

這個條件阻止了在遊戲進行中進入回放模式。

## 解決方案

### 1. 移除遊戲狀態限制

**變更位置**：`qt_chess.cpp` 第 172-187 行

移除了 `if (!m_gameStarted)` 條件檢查，允許在遊戲進行中和結束後都可以進入回放模式。

```cpp
// 之前：
if (!m_gameStarted) {  // 只有在遊戲結束後才允許回放
    // ... 回放邏輯
}

// 之後：
// 允許在遊戲進行中或結束後都可以回放
// ... 回放邏輯
```

### 2. 計時器暫停/恢復機制

**變更位置**：`qt_chess.cpp` 第 2267-2303 行

#### 2.1 進入回放模式時暫停計時器

在 `enterReplayMode()` 函數中新增：
```cpp
// 暫停計時器（如果正在進行中）
if (m_gameTimer && m_gameTimer->isActive()) {
    m_gameTimer->stop();
}
```

這確保在查看回放時，實際對局的時間不會繼續流逝。

#### 2.2 退出回放模式時恢復計時器

在 `exitReplayMode()` 函數中新增：
```cpp
// 恢復計時器（如果遊戲進行中且計時器已啟動）
if (m_gameStarted && m_timerStarted) {
    startTimer();
}
```

當玩家退出回放返回實際對局時，如果遊戲仍在進行且啟用了時間控制，計時器會繼續從暫停處計時。

#### 計時器工作原理

計時器使用 `m_whiteTimeMs` 和 `m_blackTimeMs` 成員變數儲存剩餘時間：
- 每 100ms 觸發一次 `onGameTimerTick()`
- 每次觸發時減少當前玩家的時間 100ms
- `stop()` 和 `start()` 只是停止/恢復觸發，不會重置時間值
- 因此實現了真正的暫停/恢復功能

### 3. 修正按鈕顯示邏輯

**變更位置**：`qt_chess.cpp` 第 2313-2317 行

修正了 `exitReplayMode()` 中匯出和複製 PGN 按鈕的顯示邏輯：

```cpp
// 只在遊戲結束時顯示匯出/複製按鈕
if (!m_gameStarted) {
    if (m_exportPGNButton) m_exportPGNButton->show();
    if (m_copyPGNButton) m_copyPGNButton->show();
}
```

這確保這些按鈕只在遊戲結束時顯示，不會在遊戲進行中退出回放時顯示。

## 現有的安全機制

回放模式的基礎架構已經具備適當的保護措施：

1. **棋盤狀態保存/恢復**
   - `saveBoardState()` 在進入回放前儲存完整的棋盤狀態
   - `restoreBoardState()` 在退出回放時恢復棋盤狀態
   - 包括所有棋子位置和當前玩家

2. **棋子移動封鎖**
   - `onSquareClicked()` - 回放模式中直接返回
   - `mousePressEvent()` - 回放模式中忽略滑鼠按下
   - `mouseMoveEvent()` - 回放模式中忽略滑鼠移動
   - `mouseReleaseEvent()` - 回放模式中忽略滑鼠釋放

3. **UI 狀態管理**
   - 回放控制按鈕在回放時顯示
   - 遊戲控制按鈕在回放時隱藏
   - 棋譜列表高亮當前回放位置

## 使用方式

### 基本操作

1. **開始新遊戲**並下幾步棋
2. **雙擊棋譜列表**中的任一步驟
3. 進入回放模式，看到回放控制按鈕：
   - ⏮ (第一步)：跳到初始狀態
   - ◀ (上一步)：回退一步
   - ▶ (下一步)：前進一步
   - ⏭ (最後一步)：跳到最後一步
4. **點擊「退出回放」**按鈕
5. 棋盤恢復到當前對局狀態
6. 繼續遊戲

### 時間控制下的回放

如果啟用了時間控制：
1. 進入回放時計時器自動暫停
2. 在回放中瀏覽時不消耗時間
3. 退出回放時計時器自動恢復
4. 時間從暫停處繼續計算

## 測試建議

### 基本功能測試
1. ✓ 在遊戲進行中進入回放模式
2. ✓ 在回放中瀏覽不同步驟
3. ✓ 退出回放後棋盤狀態正確
4. ✓ 退出回放後繼續遊戲

### 時間控制測試
1. ✓ 啟用時間控制並開始遊戲
2. ✓ 進入回放時計時器暫停
3. ✓ 退出回放時計時器恢復
4. ✓ 剩餘時間正確保持

### 邊界情況測試
1. ✓ 在被將軍時進入回放
2. ✓ 回放到初始狀態（moveIndex = -1）
3. ✓ 回放到最後一步
4. ✓ 遊戲結束後的回放（原有功能）

### UI 狀態測試
1. ✓ 回放控制按鈕正確顯示/隱藏
2. ✓ 匯出/複製按鈕在遊戲進行中不顯示
3. ✓ 匯出/複製按鈕在遊戲結束時顯示
4. ✓ 棋譜列表高亮正確

## 程式碼變更總結

### 變更的檔案
- `qt_chess.cpp`

### 變更的函數
1. `setupUI()` - 移除遊戲狀態檢查（第 172-187 行）
2. `enterReplayMode()` - 新增計時器暫停（第 2269-2273 行）
3. `exitReplayMode()` - 新增計時器恢復和按鈕顯示邏輯（第 2300-2317 行）

### 變更統計
- 新增行數：9 行
- 修改行數：3 行
- 刪除行數：2 行
- 總變更：14 行

## 技術細節

### 棋盤狀態管理
```cpp
// 儲存狀態
m_savedBoardState.clear();
m_savedBoardState.resize(8);
for (int row = 0; row < 8; ++row) {
    for (int col = 0; col < 8; ++col) {
        m_savedBoardState[row][col] = m_chessBoard.getPiece(row, col);
    }
}
m_savedCurrentPlayer = m_chessBoard.getCurrentPlayer();

// 恢復狀態
for (int row = 0; row < 8; ++row) {
    for (int col = 0; col < 8; ++col) {
        m_chessBoard.setPiece(row, col, m_savedBoardState[row][col]);
    }
}
m_chessBoard.setCurrentPlayer(m_savedCurrentPlayer);
```

### 計時器暫停/恢復流程
1. 進入回放：`m_gameTimer->stop()` - 停止觸發 tick 事件
2. 時間值保持：`m_whiteTimeMs` 和 `m_blackTimeMs` 不變
3. 退出回放：`m_gameTimer->start(100)` - 繼續觸發 tick 事件
4. 計時繼續：從儲存的時間值繼續減少

## 未來改進建議

1. **鍵盤快捷鍵**
   - 左/右箭頭：上一步/下一步
   - Home/End：第一步/最後一步
   - Esc：退出回放

2. **自動播放**
   - 新增播放/暫停按鈕
   - 可調整播放速度
   - 循環播放選項

3. **回放進度條**
   - 視覺化顯示當前回放位置
   - 可拖動跳到任意步驟
   - 顯示步數資訊

4. **觸控支援**
   - 滑動手勢切換步驟
   - 雙指縮放棋盤
   - 長按顯示提示

## 授權

本功能是 Qt_Chess 專案的一部分，遵循專案的授權條款。

## 貢獻者

- GitHub Copilot Workspace Agent
- 41343112 (原始專案作者)
