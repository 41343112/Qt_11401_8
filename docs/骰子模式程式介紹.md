# Qt_Chess 骰子模式程式碼詳細介紹
## Dice Mode Code Documentation & Presentation

---

## 目錄 Table of Contents

1. 骰子模式概述 (Dice Mode Overview)
2. 核心資料結構 (Core Data Structures)
3. 主要功能函數 (Main Functions)
4. 骰子擲出流程 (Dice Rolling Process)
5. 移動驗證機制 (Move Validation Mechanism)
6. 顯示更新系統 (Display Update System)
7. 將軍中斷規則 (Check Interruption Rule)
8. 網路同步機制 (Network Synchronization)
9. 程式碼架構圖 (Code Architecture)
10. 實際範例演示 (Examples)

---

## 1. 骰子模式概述
### Dice Mode Overview

### 功能說明
骰子模式是 Qt_Chess 的一個特殊遊戲模式，增加了遊戲的隨機性和策略性。

**核心機制：**
- 每回合開始時擲出 3 個骰子
- 每個骰子代表一種棋子類型（王、后、車、象、馬、兵）
- 玩家必須依序移動這 3 種類型的棋子各一次
- 只能移動骰出的棋子類型

**特殊規則：**
- 王棋只能在一回合中骰出一次（避免過度依賴王棋）
- 將軍中斷：當將對手將軍時，對手必須先應對，然後攻擊方繼續完成剩餘移動
- 動態顯示：骰子會根據棋子是否存在、是否有合法移動來顯示灰階

---

## 2. 核心資料結構
### Core Data Structures

### 2.1 類別成員變數 (qt_chess.h: 279-294)

```cpp
// 骰子模式相關 (Dice Mode)
bool m_diceModeEnabled;              // 是否啟用骰子模式
std::vector<PieceType> m_rolledPieceTypes;      // 本回合骰出的棋子類型
std::vector<int> m_rolledPieceTypeCounts;       // 每種類型剩餘可移動次數
QWidget* m_diceDisplayPanel;         // 骰子顯示面板
QLabel* m_diceDisplayTitle;          // 骰子面板標題（顯示輪到誰）
QList<QLabel*> m_diceDisplayLabels;  // 顯示骰出棋子的標籤（3個）
int m_diceMovesRemaining;            // 本回合剩餘可移動的骰子數量

// 骰子模式將軍中斷相關 (Dice Mode Check Interruption)
bool m_diceCheckInterrupted;         // 骰子模式是否因將軍而中斷
PieceColor m_diceInterruptedPlayer;  // 被中斷的玩家顏色
bool m_diceRespondingToCheck;        // 當前玩家是否正在應對將軍
std::vector<PieceType> m_diceSavedPieceTypes;      // 中斷前保存的骰子類型
std::vector<int> m_diceSavedPieceTypeCounts;       // 中斷前保存的次數
int m_diceSavedMovesRemaining;       // 中斷前保存的剩餘移動次數
```

### 2.2 資料結構說明

| 變數名稱 | 類型 | 用途 |
|---------|------|------|
| `m_rolledPieceTypes` | `vector<PieceType>` | 儲存本回合骰出的 3 種棋子類型 |
| `m_rolledPieceTypeCounts` | `vector<int>` | 每種棋子的剩餘移動次數（初始都是1） |
| `m_diceMovesRemaining` | `int` | 總剩餘移動次數（初始為3） |
| `m_diceCheckInterrupted` | `bool` | 標記是否被將軍中斷 |
| `m_diceSavedPieceTypes` | `vector<PieceType>` | 中斷時備份的骰子狀態 |

---

## 3. 主要功能函數
### Main Functions

### 3.1 函數列表

| 函數名稱 | 行數 | 功能說明 |
|---------|------|----------|
| `rollDiceForTurn()` | 8933-8971 | 為當前回合骰出 3 個棋子類型 |
| `onDiceRolled()` | 8974-9085 | 處理從伺服器收到的骰子結果 |
| `onDiceStateReceived()` | 9088-9149 | 處理骰子狀態更新 |
| `updateDiceDisplay()` | 9152-9229 | 更新骰子顯示面板的 UI |
| `isPieceTypeInRolledList()` | 9232-9249 | 檢查棋子類型是否在骰出列表中 |
| `markPieceTypeAsMoved()` | 9252-9266 | 標記骰出的棋子類型已移動 |
| `allRolledPiecesMoved()` | 9269-9297 | 檢查是否所有骰子都已使用 |
| `canPieceTypeMove()` | 8917-8930 | 檢查該類型棋子是否能移動 |
| `canRollPiece()` | 9300-9317 | 檢查該位置棋子是否可被骰出 |

---

## 4. 骰子擲出流程
### Dice Rolling Process

### 4.1 流程圖

```
[回合開始] 
    ↓
[rollDiceForTurn()] - 客戶端請求骰子
    ↓
[requestDiceRoll()] - 發送網路請求到伺服器
    ↓
[伺服器生成隨機數]
    ↓
[onDiceRolled()] - 收到伺服器的骰子結果
    ↓
[處理骰子結果並更新本地狀態]
    ↓
[updateDiceDisplay()] - 更新 UI 顯示
    ↓
[玩家開始移動棋子]
```

### 4.2 核心程式碼：rollDiceForTurn()

**檔案：** `src/qt_chess.cpp` (行 8933-8971)

```cpp
void Qt_Chess::rollDiceForTurn() {
    if (!m_diceModeEnabled || !m_isOnlineGame) {
        return;  // 只在線上骰子模式中使用
    }
    
    PieceColor currentColor = m_chessBoard.getCurrentPlayer();
    qDebug() << "[Qt_Chess::rollDiceForTurn] Rolling dice for" 
             << (currentColor == PieceColor::White ? "White" : "Black");
    
    // 步驟 1: 獲取所有可移動的棋子
    std::vector<QPoint> movablePieces = getMovablePieces(currentColor);
    
    if (movablePieces.empty()) {
        // 沒有可移動的棋子，清空骰子狀態
        m_rolledPieceTypes.clear();
        m_rolledPieceTypeCounts.clear();
        m_diceMovesRemaining = 0;
        updateDiceDisplay();
        return;
    }
    
    // 步驟 2: 統計每種棋子類型的數量
    std::map<PieceType, int> pieceTypeCounts;
    for (const auto& pos : movablePieces) {
        const ChessPiece& piece = m_chessBoard.getPiece(pos.y(), pos.x());
        pieceTypeCounts[piece.getType()]++;
    }
    
    // 步驟 3: 創建可選擇的棋子類型列表
    std::vector<PieceType> availableTypes;
    for (const auto& pair : pieceTypeCounts) {
        availableTypes.push_back(pair.first);
    }
    
    // 步驟 4: 請求伺服器生成骰子
    if (m_networkManager) {
        m_networkManager->requestDiceRoll(
            static_cast<int>(availableTypes.size())
        );
    }
}
```

---

## 5. 移動驗證機制
### Move Validation Mechanism

### 5.1 驗證流程

```
[玩家嘗試移動棋子]
    ↓
[isPieceTypeInRolledList()] - 檢查棋子類型是否在骰出列表中
    ↓
    YES → [允許移動] → [markPieceTypeAsMoved()] - 標記為已移動
    ↓                        ↓
    NO → [拒絕移動]       [減少計數器] → [updateDiceDisplay()]
```

### 5.2 核心程式碼：isPieceTypeInRolledList()

**檔案：** `src/qt_chess.cpp` (行 9232-9249)

```cpp
bool Qt_Chess::isPieceTypeInRolledList(PieceType type) const {
    // 如果未啟用骰子模式，所有棋子都可以移動
    if (!m_diceModeEnabled) {
        return true;
    }
    
    // 如果玩家正在應對將軍，允許移動任何棋子
    if (m_diceRespondingToCheck) {
        return true;
    }
    
    // 檢查骰子列表中是否有該類型且還有剩餘次數
    for (size_t i = 0; i < m_rolledPieceTypes.size(); ++i) {
        if (m_rolledPieceTypes[i] == type && 
            m_rolledPieceTypeCounts[i] > 0) {
            return true;
        }
    }
    
    return false;  // 不在列表中或已用完
}
```

### 5.3 核心程式碼：markPieceTypeAsMoved()

**檔案：** `src/qt_chess.cpp` (行 9252-9266)

```cpp
void Qt_Chess::markPieceTypeAsMoved(PieceType type) {
    if (!m_diceModeEnabled) {
        return;
    }
    
    // 找到對應的骰子並減少計數
    for (size_t i = 0; i < m_rolledPieceTypes.size(); ++i) {
        if (m_rolledPieceTypes[i] == type && 
            m_rolledPieceTypeCounts[i] > 0) {
            m_rolledPieceTypeCounts[i]--;  // 減少該類型的次數
            m_diceMovesRemaining--;        // 減少總移動次數
            
            qDebug() << "[markPieceTypeAsMoved] Marked dice" << (i + 1) 
                     << "as moved. Remaining:" << m_diceMovesRemaining;
            
            updateDiceDisplay();  // 更新 UI（可能變灰階）
            return;
        }
    }
}
```

---

## 6. 顯示更新系統
### Display Update System

### 6.1 UI 組件

骰子顯示面板包含：
- **標題標籤** (`m_diceDisplayTitle`)：顯示「🎲 輪到我」或「⏸️ 對手回合」
- **3 個骰子標籤** (`m_diceDisplayLabels`)：顯示骰出的棋子類型

### 6.2 顯示狀態

| 狀態 | 外觀 | 條件 |
|------|------|------|
| **彩色（可用）** | 藍色漸變背景 | 剩餘次數 > 0 且該類型棋子可移動 |
| **灰階（不可用）** | 灰色背景 | 剩餘次數 = 0 或該類型棋子不能移動 |
| **空白** | 顯示 "--" | 該骰子位置沒有骰出棋子 |

### 6.3 核心程式碼：updateDiceDisplay()

**檔案：** `src/qt_chess.cpp` (行 9152-9229)

```cpp
void Qt_Chess::updateDiceDisplay() {
    if (!m_diceDisplayPanel || m_diceDisplayLabels.isEmpty()) {
        return;
    }
    
    // 骰子模式啟用時顯示面板
    if (m_diceModeEnabled && m_isOnlineGame) {
        m_diceDisplayPanel->show();
        
        // 更新回合指示器
        if (m_diceDisplayTitle) {
            QString turnText = isOnlineTurn() ? 
                "🎲 輪到我" : "⏸️ 對手回合";
            m_diceDisplayTitle->setText(turnText);
        }
        
        // 更新每個骰子標籤
        for (int i = 0; i < 3 && i < m_diceDisplayLabels.size(); ++i) {
            QLabel* label = m_diceDisplayLabels[i];
            
            if (i < static_cast<int>(m_rolledPieceTypes.size())) {
                PieceType type = m_rolledPieceTypes[i];
                int remainingMoves = m_rolledPieceTypeCounts[i];
                
                // 獲取棋子類型的中文名稱
                QString pieceTypeName;
                switch (type) {
                    case PieceType::King:   pieceTypeName = "王"; break;
                    case PieceType::Queen:  pieceTypeName = "后"; break;
                    case PieceType::Rook:   pieceTypeName = "車"; break;
                    case PieceType::Bishop: pieceTypeName = "象"; break;
                    case PieceType::Knight: pieceTypeName = "馬"; break;
                    case PieceType::Pawn:   pieceTypeName = "兵"; break;
                    default: pieceTypeName = "?"; break;
                }
                
                label->setText(pieceTypeName);
                
                // 判斷是否應該灰階顯示
                PieceColor diceOwnerColor = m_chessBoard.getCurrentPlayer();
                bool canMove = canPieceTypeMove(type, diceOwnerColor);
                
                if (remainingMoves <= 0 || !canMove) {
                    // 灰階樣式
                    label->setStyleSheet(
                        "QLabel { "
                        "  background: qlineargradient(x1:0, y1:0, x2:0, y2:1, "
                        "    stop:0 rgba(80, 80, 80, 0.5), "
                        "    stop:1 rgba(40, 40, 40, 0.7)); "
                        "  color: #808080; "
                        "  border: 2px solid #606060; "
                        "  border-radius: 8px; "
                        "}"
                    );
                } else {
                    // 彩色樣式（可用）
                    label->setStyleSheet(
                        "QLabel { "
                        "  background: qlineargradient(x1:0, y1:0, x2:0, y2:1, "
                        "    stop:0 rgba(33, 150, 243, 0.3), "
                        "    stop:1 rgba(26, 26, 46, 0.95)); "
                        "  color: #2196F3; "
                        "  border: 2px solid #2196F3; "
                        "  border-radius: 8px; "
                        "}"
                    );
                }
            } else {
                label->setText("--");  // 空骰子位置
            }
        }
    } else {
        m_diceDisplayPanel->hide();  // 非骰子模式時隱藏
    }
}
```

### 6.4 動態灰階檢查：canPieceTypeMove()

**檔案：** `src/qt_chess.cpp` (行 8917-8930)

```cpp
bool Qt_Chess::canPieceTypeMove(PieceType type, PieceColor color) const {
    // 獲取所有可移動的棋子
    std::vector<QPoint> movablePieces = getMovablePieces(color);
    
    // 檢查是否有任何可移動的棋子屬於指定類型
    for (const auto& pos : movablePieces) {
        const ChessPiece& piece = m_chessBoard.getPiece(pos.y(), pos.x());
        if (piece.getType() == type) {
            return true;  // 找到該類型的可移動棋子
        }
    }
    
    return false;  // 該類型棋子都被吃掉或被擋住
}
```

**功能：** 檢查該類型的棋子是否：
1. 還存在於棋盤上
2. 至少有一個可以合法移動

如果兩個條件都滿足，返回 `true`（顯示彩色），否則返回 `false`（顯示灰階）。

---

## 7. 將軍中斷規則
### Check Interruption Rule

### 7.1 規則說明

**中文：** 當玩家在骰子回合中將對手的王將軍（但不是將死）時：
1. 系統保存當前玩家剩餘的骰子移動
2. 回合立即切換到對手
3. 對手必須先移動一步來解決將軍
4. 對手移動後，回合自動切換回被中斷的玩家
5. 被中斷的玩家可以繼續完成剩餘的骰子移動

### 7.2 狀態保存與恢復流程

```
[玩家移動棋子] 
    ↓
[檢測：對手是否被將軍？] 
    ↓ YES (且不是將死，且還有剩餘骰子)
[保存骰子狀態]
    - m_diceSavedPieceTypes = m_rolledPieceTypes
    - m_diceSavedMovesRemaining = m_diceMovesRemaining
    ↓
[清空當前骰子狀態]
    - m_rolledPieceTypes.clear()
    - m_diceMovesRemaining = 0
    ↓
[設置中斷標記]
    - m_diceCheckInterrupted = true
    - m_diceInterruptedPlayer = currentPlayer
    ↓
[切換回合到對手] - 對手應對將軍
    ↓
[對手移動解除將軍]
    ↓
[onOpponentMove() 檢測中斷恢復]
    ↓
[恢復骰子狀態]
    - m_rolledPieceTypes = m_diceSavedPieceTypes
    - m_diceMovesRemaining = m_diceSavedMovesRemaining
    ↓
[切換回合回到被中斷玩家]
    ↓
[被中斷玩家繼續移動剩餘骰子]
```

### 7.3 核心程式碼：檢測並保存（點擊移動）

**檔案：** `src/qt_chess.cpp` (行 2567-2655)

```cpp
// 在 mousePressEvent 處理移動後

// 檢查對手是否被將軍
PieceColor opponentColor = m_chessBoard.getCurrentPlayer();
bool opponentInCheck = m_chessBoard.isInCheck(opponentColor);
bool opponentInCheckmate = m_chessBoard.isCheckmate(opponentColor);

qDebug() << "[Qt_Chess] After move - opponentInCheck:" << opponentInCheck 
         << "| opponentInCheckmate:" << opponentInCheckmate
         << "| m_diceMovesRemaining=" << m_diceMovesRemaining;

// 如果對手被將軍（但不是將死）且還有剩餘骰子，需要中斷
// 注意：這裡檢查 m_diceMovesRemaining - 1 > 0，
// 因為當前移動還沒有被標記（尚未調用 markPieceTypeAsMoved）
if (opponentInCheck && !opponentInCheckmate && 
    m_diceMovesRemaining - 1 > 0) {
    
    int diceMovesSaved = m_diceMovesRemaining - 1;
    
    // 發送移動訊息時包含中斷標記
    m_networkManager->sendMove(from, to, prom, final, 
                               true,           // causesCheckInterruption
                               diceMovesSaved); // savedDiceMoves
    
    qDebug() << "[Qt_Chess] Check interruption! Saved" 
             << diceMovesSaved << "dice moves";
    
    // 本地標記該棋子類型已使用一次
    markPieceTypeAsMoved(movedPieceType);
    
    // 不在這裡保存狀態！
    // 等到 onOpponentMove 收到對手的回應後再處理中斷邏輯
    
} else {
    // 正常移動，不需要中斷
    m_networkManager->sendMove(from, to, prom, final, 
                               false, 0);
    markPieceTypeAsMoved(movedPieceType);
}
```

### 7.4 核心程式碼：恢復中斷

**檔案：** `src/qt_chess.cpp` (行 6267-6296)

```cpp
// 在 onOpponentMove() 函數中

// 檢查是否需要恢復被中斷的回合
if (m_diceCheckInterrupted && 
    m_diceInterruptedPlayer == myColor) {
    
    qDebug() << "[Qt_Chess::onOpponentMove] Checking if should restore "
             << "interrupted turn for" 
             << (myColor == PieceColor::White ? "White" : "Black");
    
    // 檢查我方是否還在被將軍狀態
    bool stillInCheck = m_chessBoard.isInCheck(myColor);
    
    if (!stillInCheck) {
        // 將軍已解除，恢復之前的骰子狀態
        qDebug() << "[Qt_Chess::onOpponentMove] Check resolved, "
                 << "restoring dice state";
        
        m_rolledPieceTypes = m_diceSavedPieceTypes;
        m_rolledPieceTypeCounts = m_diceSavedPieceTypeCounts;
        m_diceMovesRemaining = m_diceSavedMovesRemaining;
        
        // 清除中斷標記
        m_diceCheckInterrupted = false;
        m_diceInterruptedPlayer = PieceColor::None;
        m_diceSavedPieceTypes.clear();
        m_diceSavedPieceTypeCounts.clear();
        m_diceSavedMovesRemaining = 0;
        
        // 切換回合回到被中斷的玩家（我方）
        m_chessBoard.setCurrentPlayer(myColor);
        
        qDebug() << "[Qt_Chess::onOpponentMove] Restored dice state: " 
                 << m_diceMovesRemaining << " moves remaining";
        
        updateDiceDisplay();
        updateStatus();
        return;  // 重要：這裡 return，不繼續下面的換邊邏輯
    }
}
```

---

## 8. 網路同步機制
### Network Synchronization

### 8.1 網路通訊流程

```
[客戶端 A] ─────────> [伺服器] <───────── [客戶端 B]
    │                     │                   │
    │ requestDiceRoll()   │                   │
    ├──────────────────> │                   │
    │                     │ 生成隨機骰子       │
    │                     ├──────────────────>│
    │ <───────────────────┤ diceRolled 訊息   │
    │   onDiceRolled()    │                   │
    │                     │                   │
    │ sendMove()          │                   │
    ├──────────────────> │                   │
    │                     ├──────────────────>│
    │                     │ move 訊息         │
    │                     │ onOpponentMove()  │
    │                     │                   │
    │                     │ diceStateUpdate   │
    │ <───────────────────┤                   │
    │ onDiceStateReceived()                   │
```

### 8.2 關鍵網路函數

#### requestDiceRoll() - 請求骰子

**檔案：** `src/networkmanager.cpp` (行 281-294)

```cpp
void NetworkManager::requestDiceRoll(int numMovablePieces) {
    if (m_roomNumber.isEmpty()) {
        qDebug() << "[NetworkManager::requestDiceRoll] "
                 << "ERROR: Room number is empty";
        return;
    }
    
    QJsonObject message;
    message["type"] = "requestDiceRoll";
    message["room"] = m_roomNumber;
    message["numPieces"] = numMovablePieces;
    
    sendMessage(message);
    
    qDebug() << "[NetworkManager::requestDiceRoll] "
             << "Requesting dice roll for" << numMovablePieces 
             << "movable pieces";
}
```

#### sendMove() - 發送移動（包含中斷資訊）

**檔案：** `src/networkmanager.cpp` (行 197-243)

```cpp
void NetworkManager::sendMove(const QPoint& from, const QPoint& to,
                              PieceType promotionType,
                              QPoint finalPosition,
                              bool causesCheckInterruption,
                              int savedDiceMoves) {
    QJsonObject message;
    message["type"] = "move";
    message["room"] = m_roomNumber;
    message["from"] = QJsonObject{
        {"x", from.x()}, {"y", from.y()}
    };
    message["to"] = QJsonObject{
        {"x", to.x()}, {"y", to.y()}
    };
    
    // ... 其他欄位 ...
    
    // 新增：將軍中斷資訊
    if (causesCheckInterruption && savedDiceMoves > 0) {
        message["diceCheckInterruption"] = true;
        message["savedDiceMoves"] = savedDiceMoves;
    }
    
    sendMessage(message);
}
```

### 8.3 伺服器端邏輯（server.js）

**檔案：** `server.js` (行 191-213)

```javascript
// 處理移動訊息
if (msg.type === 'move') {
    // 骰子模式處理
    if (diceRolls[roomId]) {
        // 檢查是否有將軍中斷標記
        if (msg.diceCheckInterruption && msg.savedDiceMoves > 0) {
            console.log('[Server] Check interruption detected!');
            
            // 保存被中斷玩家的狀態
            diceRolls[roomId].interruptedPlayer = playerWhoJustMoved;
            diceRolls[roomId].savedMovesRemaining = msg.savedDiceMoves;
            diceRolls[roomId].movesRemaining = 0;
            
            // 強制切換回合
            shouldSwitchPlayer = true;
        } else {
            // 正常的骰子邏輯
            if (diceRolls[roomId].movesRemaining > 0) {
                diceRolls[roomId].movesRemaining--;
            }
            shouldSwitchPlayer = (diceRolls[roomId].movesRemaining <= 0);
        }
    }
    
    // 廣播移動給房間內其他玩家
    // ...
}
```

---

## 9. 程式碼架構圖
### Code Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                        Qt_Chess 主類別                        │
│                     (qt_chess.h/cpp)                         │
└─────────────────────────────────────────────────────────────┘
                            │
        ┌───────────────────┼───────────────────┐
        │                   │                   │
        ▼                   ▼                   ▼
┌──────────────┐   ┌──────────────┐   ┌──────────────┐
│ 骰子狀態管理  │   │  移動驗證     │   │  UI 顯示     │
│              │   │              │   │              │
│ • 骰子變數   │   │ • 檢查類型   │   │ • 面板更新   │
│ • 狀態保存   │   │ • 標記使用   │   │ • 灰階判斷   │
│ • 中斷處理   │   │ • 合法驗證   │   │ • 樣式設定   │
└──────────────┘   └──────────────┘   └──────────────┘
        │                   │                   │
        └───────────────────┼───────────────────┘
                            │
                            ▼
                ┌──────────────────────┐
                │   ChessBoard 類別     │
                │  (chessboard.h/cpp)  │
                │                      │
                │  • isValidMove()     │
                │  • isInCheck()       │
                │  • isCheckmate()     │
                │  • getCurrentPlayer()│
                └──────────────────────┘
                            │
                            ▼
                ┌──────────────────────┐
                │ NetworkManager 類別   │
                │(networkmanager.h/cpp)│
                │                      │
                │ • requestDiceRoll()  │
                │ • sendMove()         │
                │ • sendMessage()      │
                └──────────────────────┘
                            │
                            ▼
                    ┌──────────────┐
                    │   WebSocket  │
                    │   伺服器      │
                    │  (server.js) │
                    └──────────────┘
```

---

## 10. 實際範例演示
### Examples

### 範例 1：正常骰子回合

```
回合開始：白方
├─ rollDiceForTurn()
├─ 伺服器返回骰子：[Knight, Rook, Pawn]
├─ onDiceRolled() 處理結果
├─ updateDiceDisplay() 顯示：馬(藍) 車(藍) 兵(藍)
│
├─ 玩家移動馬
│   ├─ isPieceTypeInRolledList(Knight) → true ✓
│   ├─ movePiece() 執行移動
│   ├─ markPieceTypeAsMoved(Knight)
│   └─ updateDiceDisplay() 顯示：馬(灰) 車(藍) 兵(藍)
│
├─ 玩家移動車
│   ├─ isPieceTypeInRolledList(Rook) → true ✓
│   ├─ movePiece() 執行移動
│   ├─ markPieceTypeAsMoved(Rook)
│   └─ updateDiceDisplay() 顯示：馬(灰) 車(灰) 兵(藍)
│
├─ 玩家移動兵
│   ├─ isPieceTypeInRolledList(Pawn) → true ✓
│   ├─ movePiece() 執行移動
│   ├─ markPieceTypeAsMoved(Pawn)
│   ├─ updateDiceDisplay() 顯示：馬(灰) 車(灰) 兵(灰)
│   └─ allRolledPiecesMoved() → true
│
└─ 切換回合到黑方
```

### 範例 2：將軍中斷

```
回合開始：白方
├─ 骰子：[Queen, Bishop, Knight]
├─ 顯示：后(藍) 象(藍) 馬(藍)
│
├─ 玩家移動后
│   ├─ movePiece() 執行移動
│   ├─ 黑王被將軍！（不是將死）
│   ├─ markPieceTypeAsMoved(Queen)
│   ├─ 顯示：后(灰) 象(藍) 馬(藍)
│   │
│   ├─ 檢測中斷條件：
│   │   ├─ opponentInCheck = true ✓
│   │   ├─ opponentInCheckmate = false ✓
│   │   └─ m_diceMovesRemaining - 1 = 2 > 0 ✓
│   │
│   ├─ 發送帶中斷標記的移動
│   │   sendMove(from, to, ..., 
│   │            causesCheckInterruption=true,
│   │            savedDiceMoves=2)
│   │
│   └─ 等待對手應對
│
├─ 切換到黑方（應對將軍）
│   ├─ 黑方移動國王逃離將軍
│   └─ 發送移動到伺服器
│
├─ onOpponentMove() 收到黑方移動
│   ├─ 檢測：m_diceCheckInterrupted = true
│   ├─ 檢測：stillInCheck = false（將軍已解除）
│   │
│   ├─ 恢復白方骰子狀態：
│   │   ├─ m_rolledPieceTypes = [Queen, Bishop, Knight]
│   │   ├─ m_rolledPieceTypeCounts = [0, 1, 1]
│   │   └─ m_diceMovesRemaining = 2
│   │
│   ├─ 清除中斷標記
│   ├─ 切換回合回到白方
│   └─ updateDiceDisplay() 顯示：后(灰) 象(藍) 馬(藍)
│
├─ 白方繼續移動象
│   └─ 顯示：后(灰) 象(灰) 馬(藍)
│
├─ 白方移動馬
│   └─ 顯示：后(灰) 象(灰) 馬(灰)
│
└─ 所有骰子用完，切換到黑方
```

### 範例 3：動態灰階

```
回合開始：白方
├─ 骰子：[Rook, Knight, Pawn]
├─ 初始顯示：車(藍) 馬(藍) 兵(藍)
│
├─ 玩家移動車
│   └─ 顯示：車(灰) 馬(藍) 兵(藍)
│
├─ 切換到黑方
│   └─ 黑方吃掉白方的最後一個馬！
│
├─ 切換回白方
│   ├─ updateDiceDisplay() 被調用
│   ├─ canPieceTypeMove(Knight, White) 檢查
│   │   └─ 返回 false（所有馬都被吃了）
│   │
│   └─ 顯示：車(灰) 馬(灰 - 自動!) 兵(藍)
│       （馬變成灰色，因為已經沒有馬可以移動）
│
└─ 玩家只能移動兵來完成回合
```

---

## 總結
### Summary

### 關鍵特點

1. **完整的狀態管理**
   - 使用向量儲存骰子類型和計數
   - 清晰的中斷保存與恢復機制
   - 多層次的驗證檢查

2. **動態 UI 更新**
   - 即時反映棋子狀態
   - 自動灰階顯示不可用骰子
   - 美觀的漸變樣式

3. **網路同步**
   - 伺服器生成隨機骰子確保公平性
   - 雙向狀態同步
   - 支援中斷資訊傳遞

4. **將軍中斷規則**
   - 複雜的邏輯處理
   - 狀態保存與恢復
   - 確保遊戲公平性

### 程式碼統計

| 項目 | 數量 |
|------|------|
| 核心函數 | 9 個 |
| 狀態變數 | 13 個 |
| 總程式碼行數 | 約 600+ 行 |
| 文件檔案 | 4 個 MD 文件 |

### 技術亮點

✅ 模組化設計  
✅ 清晰的職責分離  
✅ 完善的錯誤處理  
✅ 詳細的 Debug 日誌  
✅ 優雅的 UI/UX  
✅ 可擴展的架構  

---

## 參考文件
### Reference Documents

1. **DICE_MODE_CHECK_RULE.md** - 將軍中斷規則詳細說明
2. **FEATURE_DYNAMIC_DICE_DISPLAY.md** - 動態顯示更新功能
3. **BUGFIX_DICE_CHECK_MOVEMENT.md** - 第一次修復：移動驗證
4. **BUGFIX_DICE_SERVER_SYNC.md** - 第二次修復：伺服器同步
5. **BUGFIX_DICE_ATOMIC_MESSAGE.md** - 第三次修復：原子訊息
6. **IMPLEMENTATION_SUMMARY_DICE_CHECK.md** - 實現摘要

---

## 結語

骰子模式是 Qt_Chess 中最複雜的功能之一，整合了：
- 遊戲邏輯
- UI 設計
- 網路通訊
- 狀態管理

程式碼設計優雅、模組化良好，展現了專業的軟體工程實踐。

**感謝您的閱讀！**

---

*文件製作日期：2026-01-04*  
*版本：1.0*
